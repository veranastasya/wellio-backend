/* tslint:disable */
/* eslint-disable */
/**
 * Wellio Core API
 * Core API for the Wellio wellness coaching platform
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@wellio.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateClient,
  CreateSession,
  DataImport,
  HealthResponse,
  IntegrationConnect,
  ModelApiResponse,
  QuestionnaireSend,
  UpdateClient,
  UpdateSession,
  UpdateUserRequest,
} from '../models/index';
import {
    CreateClientFromJSON,
    CreateClientToJSON,
    CreateSessionFromJSON,
    CreateSessionToJSON,
    DataImportFromJSON,
    DataImportToJSON,
    HealthResponseFromJSON,
    HealthResponseToJSON,
    IntegrationConnectFromJSON,
    IntegrationConnectToJSON,
    ModelApiResponseFromJSON,
    ModelApiResponseToJSON,
    QuestionnaireSendFromJSON,
    QuestionnaireSendToJSON,
    UpdateClientFromJSON,
    UpdateClientToJSON,
    UpdateSessionFromJSON,
    UpdateSessionToJSON,
    UpdateUserRequestFromJSON,
    UpdateUserRequestToJSON,
} from '../models/index';

export interface ApiV1AnalyticsExportGetRequest {
    range: string;
    format?: ApiV1AnalyticsExportGetFormatEnum;
}

export interface ApiV1AnalyticsRevenueForecastGetRequest {
    range: string;
}

export interface ApiV1AnalyticsSummaryGetRequest {
    range: ApiV1AnalyticsSummaryGetRangeEnum;
}

export interface ApiV1ClientsGetRequest {
    status?: string;
    service?: string;
    query?: string;
    sort?: string;
    page?: number;
    pageSize?: number;
}

export interface ApiV1ClientsIdGetRequest {
    id: string;
}

export interface ApiV1ClientsIdPatchRequest {
    id: string;
    updateClient: UpdateClient;
}

export interface ApiV1ClientsPostRequest {
    createClient: CreateClient;
}

export interface ApiV1DataImportsManualPostRequest {
    dataImport: DataImport;
}

export interface ApiV1DataImportsStatusGetRequest {
    clientId?: string;
}

export interface ApiV1InsightsClientsGetRequest {
    limit?: number;
}

export interface ApiV1InsightsGetRequest {
    scope?: string;
    type?: string;
    limit?: number;
}

export interface ApiV1IntegrationsFatsecretConnectPostRequest {
    integrationConnect: IntegrationConnect;
}

export interface ApiV1IntegrationsFatsecretWebhookPostRequest {
    body: object;
}

export interface ApiV1IntegrationsMfpConnectPostRequest {
    integrationConnect: IntegrationConnect;
}

export interface ApiV1IntegrationsMfpWebhookPostRequest {
    body: object;
}

export interface ApiV1MePatchRequest {
    updateUserRequest: UpdateUserRequest;
}

export interface ApiV1NotificationsGetRequest {
    unread?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiV1NotificationsIdReadPostRequest {
    id: string;
}

export interface ApiV1OnboardingQuestionnairesSendPostRequest {
    questionnaireSend: QuestionnaireSend;
}

export interface ApiV1PredictionsChurnGetRequest {
    limit?: number;
}

export interface ApiV1SearchGetRequest {
    query: string;
    type?: ApiV1SearchGetTypeEnum;
    limit?: number;
}

export interface ApiV1SessionsGetRequest {
    when?: ApiV1SessionsGetWhenEnum;
    status?: string;
    clientId?: string;
    limit?: number;
}

export interface ApiV1SessionsIdGetRequest {
    id: string;
}

export interface ApiV1SessionsIdJoinPostRequest {
    id: string;
}

export interface ApiV1SessionsIdPatchRequest {
    id: string;
    updateSession: UpdateSession;
}

export interface ApiV1SessionsPostRequest {
    createSession: CreateSession;
}

export interface ApiV1UploadsPostRequest {
    file?: Blob;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Export analytics data
     */
    async apiV1AnalyticsExportGetRaw(requestParameters: ApiV1AnalyticsExportGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['range'] == null) {
            throw new runtime.RequiredError(
                'range',
                'Required parameter "range" was null or undefined when calling apiV1AnalyticsExportGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['range'] != null) {
            queryParameters['range'] = requestParameters['range'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/analytics/export`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Export analytics data
     */
    async apiV1AnalyticsExportGet(requestParameters: ApiV1AnalyticsExportGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.apiV1AnalyticsExportGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get optimal scheduling recommendations
     */
    async apiV1AnalyticsOptimalSchedulingGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/analytics/optimal-scheduling`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get optimal scheduling recommendations
     */
    async apiV1AnalyticsOptimalSchedulingGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1AnalyticsOptimalSchedulingGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get revenue forecast
     */
    async apiV1AnalyticsRevenueForecastGetRaw(requestParameters: ApiV1AnalyticsRevenueForecastGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['range'] == null) {
            throw new runtime.RequiredError(
                'range',
                'Required parameter "range" was null or undefined when calling apiV1AnalyticsRevenueForecastGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['range'] != null) {
            queryParameters['range'] = requestParameters['range'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/analytics/revenue-forecast`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get revenue forecast
     */
    async apiV1AnalyticsRevenueForecastGet(requestParameters: ApiV1AnalyticsRevenueForecastGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1AnalyticsRevenueForecastGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get analytics summary
     */
    async apiV1AnalyticsSummaryGetRaw(requestParameters: ApiV1AnalyticsSummaryGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['range'] == null) {
            throw new runtime.RequiredError(
                'range',
                'Required parameter "range" was null or undefined when calling apiV1AnalyticsSummaryGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['range'] != null) {
            queryParameters['range'] = requestParameters['range'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/analytics/summary`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get analytics summary
     */
    async apiV1AnalyticsSummaryGet(requestParameters: ApiV1AnalyticsSummaryGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1AnalyticsSummaryGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get client facets for filtering
     */
    async apiV1ClientsFacetsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/clients/facets`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get client facets for filtering
     */
    async apiV1ClientsFacetsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1ClientsFacetsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get clients list
     */
    async apiV1ClientsGetRaw(requestParameters: ApiV1ClientsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        const queryParameters: any = {};

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['service'] != null) {
            queryParameters['service'] = requestParameters['service'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/clients`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get clients list
     */
    async apiV1ClientsGet(requestParameters: ApiV1ClientsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1ClientsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get client by ID
     */
    async apiV1ClientsIdGetRaw(requestParameters: ApiV1ClientsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiV1ClientsIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/clients/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get client by ID
     */
    async apiV1ClientsIdGet(requestParameters: ApiV1ClientsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1ClientsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update client
     */
    async apiV1ClientsIdPatchRaw(requestParameters: ApiV1ClientsIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiV1ClientsIdPatch().'
            );
        }

        if (requestParameters['updateClient'] == null) {
            throw new runtime.RequiredError(
                'updateClient',
                'Required parameter "updateClient" was null or undefined when calling apiV1ClientsIdPatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/clients/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateClientToJSON(requestParameters['updateClient']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Update client
     */
    async apiV1ClientsIdPatch(requestParameters: ApiV1ClientsIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1ClientsIdPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new client
     */
    async apiV1ClientsPostRaw(requestParameters: ApiV1ClientsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['createClient'] == null) {
            throw new runtime.RequiredError(
                'createClient',
                'Required parameter "createClient" was null or undefined when calling apiV1ClientsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/clients`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateClientToJSON(requestParameters['createClient']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Create a new client
     */
    async apiV1ClientsPost(requestParameters: ApiV1ClientsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1ClientsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create manual data import
     */
    async apiV1DataImportsManualPostRaw(requestParameters: ApiV1DataImportsManualPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['dataImport'] == null) {
            throw new runtime.RequiredError(
                'dataImport',
                'Required parameter "dataImport" was null or undefined when calling apiV1DataImportsManualPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/data-imports/manual`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DataImportToJSON(requestParameters['dataImport']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Create manual data import
     */
    async apiV1DataImportsManualPost(requestParameters: ApiV1DataImportsManualPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1DataImportsManualPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get data import status
     */
    async apiV1DataImportsStatusGetRaw(requestParameters: ApiV1DataImportsStatusGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        const queryParameters: any = {};

        if (requestParameters['clientId'] != null) {
            queryParameters['client_id'] = requestParameters['clientId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/data-imports/status`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get data import status
     */
    async apiV1DataImportsStatusGet(requestParameters: ApiV1DataImportsStatusGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1DataImportsStatusGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get home dashboard summary
     */
    async apiV1HomeSummaryGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/home/summary`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get home dashboard summary
     */
    async apiV1HomeSummaryGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1HomeSummaryGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get client insights
     */
    async apiV1InsightsClientsGetRaw(requestParameters: ApiV1InsightsClientsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/insights/clients`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get client insights
     */
    async apiV1InsightsClientsGet(requestParameters: ApiV1InsightsClientsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1InsightsClientsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get insights
     */
    async apiV1InsightsGetRaw(requestParameters: ApiV1InsightsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        const queryParameters: any = {};

        if (requestParameters['scope'] != null) {
            queryParameters['scope'] = requestParameters['scope'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/insights`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get insights
     */
    async apiV1InsightsGet(requestParameters: ApiV1InsightsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1InsightsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Connect FatSecret integration
     */
    async apiV1IntegrationsFatsecretConnectPostRaw(requestParameters: ApiV1IntegrationsFatsecretConnectPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['integrationConnect'] == null) {
            throw new runtime.RequiredError(
                'integrationConnect',
                'Required parameter "integrationConnect" was null or undefined when calling apiV1IntegrationsFatsecretConnectPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/integrations/fatsecret/connect`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IntegrationConnectToJSON(requestParameters['integrationConnect']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Connect FatSecret integration
     */
    async apiV1IntegrationsFatsecretConnectPost(requestParameters: ApiV1IntegrationsFatsecretConnectPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1IntegrationsFatsecretConnectPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * FatSecret webhook
     */
    async apiV1IntegrationsFatsecretWebhookPostRaw(requestParameters: ApiV1IntegrationsFatsecretWebhookPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling apiV1IntegrationsFatsecretWebhookPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/integrations/fatsecret/webhook`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * FatSecret webhook
     */
    async apiV1IntegrationsFatsecretWebhookPost(requestParameters: ApiV1IntegrationsFatsecretWebhookPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1IntegrationsFatsecretWebhookPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Connect MyFitnessPal integration
     */
    async apiV1IntegrationsMfpConnectPostRaw(requestParameters: ApiV1IntegrationsMfpConnectPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['integrationConnect'] == null) {
            throw new runtime.RequiredError(
                'integrationConnect',
                'Required parameter "integrationConnect" was null or undefined when calling apiV1IntegrationsMfpConnectPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/integrations/mfp/connect`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IntegrationConnectToJSON(requestParameters['integrationConnect']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Connect MyFitnessPal integration
     */
    async apiV1IntegrationsMfpConnectPost(requestParameters: ApiV1IntegrationsMfpConnectPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1IntegrationsMfpConnectPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * MyFitnessPal webhook
     */
    async apiV1IntegrationsMfpWebhookPostRaw(requestParameters: ApiV1IntegrationsMfpWebhookPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling apiV1IntegrationsMfpWebhookPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/integrations/mfp/webhook`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * MyFitnessPal webhook
     */
    async apiV1IntegrationsMfpWebhookPost(requestParameters: ApiV1IntegrationsMfpWebhookPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1IntegrationsMfpWebhookPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get current user profile
     */
    async apiV1MeGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/me`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get current user profile
     */
    async apiV1MeGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1MeGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Update current user profile
     */
    async apiV1MePatchRaw(requestParameters: ApiV1MePatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['updateUserRequest'] == null) {
            throw new runtime.RequiredError(
                'updateUserRequest',
                'Required parameter "updateUserRequest" was null or undefined when calling apiV1MePatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/me`;

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateUserRequestToJSON(requestParameters['updateUserRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Update current user profile
     */
    async apiV1MePatch(requestParameters: ApiV1MePatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1MePatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get notifications
     */
    async apiV1NotificationsGetRaw(requestParameters: ApiV1NotificationsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        const queryParameters: any = {};

        if (requestParameters['unread'] != null) {
            queryParameters['unread'] = requestParameters['unread'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/notifications`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get notifications
     */
    async apiV1NotificationsGet(requestParameters: ApiV1NotificationsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1NotificationsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark notification as read
     */
    async apiV1NotificationsIdReadPostRaw(requestParameters: ApiV1NotificationsIdReadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiV1NotificationsIdReadPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/notifications/{id}/read`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Mark notification as read
     */
    async apiV1NotificationsIdReadPost(requestParameters: ApiV1NotificationsIdReadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1NotificationsIdReadPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Send onboarding questionnaire
     */
    async apiV1OnboardingQuestionnairesSendPostRaw(requestParameters: ApiV1OnboardingQuestionnairesSendPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['questionnaireSend'] == null) {
            throw new runtime.RequiredError(
                'questionnaireSend',
                'Required parameter "questionnaireSend" was null or undefined when calling apiV1OnboardingQuestionnairesSendPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/onboarding/questionnaires/send`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QuestionnaireSendToJSON(requestParameters['questionnaireSend']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Send onboarding questionnaire
     */
    async apiV1OnboardingQuestionnairesSendPost(requestParameters: ApiV1OnboardingQuestionnairesSendPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1OnboardingQuestionnairesSendPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get churn predictions
     */
    async apiV1PredictionsChurnGetRaw(requestParameters: ApiV1PredictionsChurnGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/predictions/churn`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get churn predictions
     */
    async apiV1PredictionsChurnGet(requestParameters: ApiV1PredictionsChurnGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1PredictionsChurnGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search across clients, conversations, and sessions
     */
    async apiV1SearchGetRaw(requestParameters: ApiV1SearchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['query'] == null) {
            throw new runtime.RequiredError(
                'query',
                'Required parameter "query" was null or undefined when calling apiV1SearchGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/search`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Search across clients, conversations, and sessions
     */
    async apiV1SearchGet(requestParameters: ApiV1SearchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1SearchGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get sessions list
     */
    async apiV1SessionsGetRaw(requestParameters: ApiV1SessionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        const queryParameters: any = {};

        if (requestParameters['when'] != null) {
            queryParameters['when'] = requestParameters['when'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['clientId'] != null) {
            queryParameters['client_id'] = requestParameters['clientId'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/sessions`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get sessions list
     */
    async apiV1SessionsGet(requestParameters: ApiV1SessionsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1SessionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get session by ID
     */
    async apiV1SessionsIdGetRaw(requestParameters: ApiV1SessionsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiV1SessionsIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/sessions/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Get session by ID
     */
    async apiV1SessionsIdGet(requestParameters: ApiV1SessionsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1SessionsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Join a session
     */
    async apiV1SessionsIdJoinPostRaw(requestParameters: ApiV1SessionsIdJoinPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiV1SessionsIdJoinPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/sessions/{id}/join`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Join a session
     */
    async apiV1SessionsIdJoinPost(requestParameters: ApiV1SessionsIdJoinPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1SessionsIdJoinPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update session
     */
    async apiV1SessionsIdPatchRaw(requestParameters: ApiV1SessionsIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiV1SessionsIdPatch().'
            );
        }

        if (requestParameters['updateSession'] == null) {
            throw new runtime.RequiredError(
                'updateSession',
                'Required parameter "updateSession" was null or undefined when calling apiV1SessionsIdPatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/sessions/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateSessionToJSON(requestParameters['updateSession']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Update session
     */
    async apiV1SessionsIdPatch(requestParameters: ApiV1SessionsIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1SessionsIdPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new session
     */
    async apiV1SessionsPostRaw(requestParameters: ApiV1SessionsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        if (requestParameters['createSession'] == null) {
            throw new runtime.RequiredError(
                'createSession',
                'Required parameter "createSession" was null or undefined when calling apiV1SessionsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/sessions`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateSessionToJSON(requestParameters['createSession']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Create a new session
     */
    async apiV1SessionsPost(requestParameters: ApiV1SessionsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1SessionsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a file
     */
    async apiV1UploadsPostRaw(requestParameters: ApiV1UploadsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModelApiResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }


        let urlPath = `/api/v1/uploads`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelApiResponseFromJSON(jsonValue));
    }

    /**
     * Upload a file
     */
    async apiV1UploadsPost(requestParameters: ApiV1UploadsPostRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModelApiResponse> {
        const response = await this.apiV1UploadsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Health check
     */
    async healthGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HealthResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/health`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HealthResponseFromJSON(jsonValue));
    }

    /**
     * Health check
     */
    async healthGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HealthResponse> {
        const response = await this.healthGetRaw(initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ApiV1AnalyticsExportGetFormatEnum = {
    Csv: 'csv',
    Json: 'json',
    Xlsx: 'xlsx'
} as const;
export type ApiV1AnalyticsExportGetFormatEnum = typeof ApiV1AnalyticsExportGetFormatEnum[keyof typeof ApiV1AnalyticsExportGetFormatEnum];
/**
 * @export
 */
export const ApiV1AnalyticsSummaryGetRangeEnum = {
    ThisWeek: 'this_week',
    ThisMonth: 'this_month',
    ThisQuarter: 'this_quarter',
    ThisYear: 'this_year'
} as const;
export type ApiV1AnalyticsSummaryGetRangeEnum = typeof ApiV1AnalyticsSummaryGetRangeEnum[keyof typeof ApiV1AnalyticsSummaryGetRangeEnum];
/**
 * @export
 */
export const ApiV1SearchGetTypeEnum = {
    Clients: 'clients',
    Conversations: 'conversations',
    Sessions: 'sessions'
} as const;
export type ApiV1SearchGetTypeEnum = typeof ApiV1SearchGetTypeEnum[keyof typeof ApiV1SearchGetTypeEnum];
/**
 * @export
 */
export const ApiV1SessionsGetWhenEnum = {
    Today: 'today',
    Tomorrow: 'tomorrow',
    ThisWeek: 'this_week',
    NextWeek: 'next_week'
} as const;
export type ApiV1SessionsGetWhenEnum = typeof ApiV1SessionsGetWhenEnum[keyof typeof ApiV1SessionsGetWhenEnum];
